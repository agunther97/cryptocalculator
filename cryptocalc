#!/usr/bin/env python

import glob, os, code, sys, rlcompleter, readline

#contants

name="CryptoCode"
indentStr="  "
lineCap=80
lineReplacements = {
    "help":"help()",
    "exit":"exit()",
    "quit":"exit()"
}
welcomeBanner=name+"\n"+"Authored by Aaron Gunther and Grey Ruessler"+"\n"+"Enter \"help\" for help, or \"quit\" to quit."
helpMsg="This is a full featured Python shell with several enhancements.\nTab completion is present, and new functions have been added.\nEnter \"help\" to get this message, or \"quit\" to quit."
#load enums

os.chdir("./enums")

for file in glob.glob("*.py"):
	exec(open("./"+file).read())

os.chdir("../")


#set up helper func, list, etc
calculatorFunctions = {}
#structure:
#id:{
#   "name":"Readable Name",
#   "arguments_short":["x","y","z"],
#   "arguments":["arg1", "arg2", "arg3"],
#   "description":"Does something lol"
#}

def fmtWrite(s, splitSearch, indent="", hangingIndent=True):
    #this splits by line length 80 on commas
    buff=""
    cap=lineCap*1
    hanging=not hangingIndent
    if not hanging:
        cap=cap-len(indent)
    while len(s)>0:
        p = s.find(splitSearch)
        if (p==-1):
            if (len(s)+len(buff))>cap:
                print(buff)
                print(s)
                buff=""
                s=""
            else:
                buff+=s
                s=""
        else:
            doTrim=False
            if (len(buff)+p)>cap:
                if hanging:
                    buff=indent+buff
                    doTrim=True
                else:
                    hanging=True
                    cap=lineCap-len(indent)
                print(buff)
                buff=""
            cut=p+len(splitSearch)
            buff+=s[0:cut]
            if doTrim:
                buff=buff.lstrip()
            s=s[cut:len(s)]
    if len(buff)>0:
        if indent and hanging:
            buff=indent+buff
        print(buff)
def registerFunction(fn, data):
    calculatorFunctions[fn]=data
    
def displayFunctions():
    sz=len(calculatorFunctions.keys())
    funcList = [None for x in range(sz)]
    i=0
    for k,v in calculatorFunctions.items():
        funcList[i]=k
        i+=1
    funcList.sort()
    i=0
    s=""
    for f in funcList:
        s+=f+"("
        data = calculatorFunctions[f]
        args = None
        if "arguments_short" in data:
            args=data["arguments_short"]
        elif "arguments" in data:
            args=data["arguments"]

        if not (args is None):
            for j in range(len(args)):
                s=s+args[j]
                if j<len(args)-1:
                    s=s+","
            s=s+")"
            if (i<len(funcList)-1):
                s=s+", "
            i=i+1
    print("Registered Functions:")
    fmtWrite(s,"),",indent=indentStr,hangingIndent=False)
    print("Use help(functionName) for more information.")

def displayFunction(fn):
    data=calculatorFunctions[fn]

    if "name" in data:
        print(data["name"])
    else:
        print(fn)
    args = []
    if "arguments" in data:
        args=data["arguments"]
    elif "arguments_short" in data:
        args=data["arguments_short"]
    s="Usage: " + fn + "("
    for j in range(len(args)):
        s=s+args[j]
        if j<len(args)-1:
            s=s+", "
    s=s+")"
    fmtWrite(indentStr+s," ",indent=(indentStr+indentStr))
    if "description" in data:
        fmtWrite(indentStr+data["description"], " ",indent=(indentStr+indentStr))

def help(*args):
    funcName=""
    for arg in args:
        if len(funcName)>0:
            funcName = funcName + " "
        if callable(arg):
            funcName = funcName + arg.__name__
        else:
            funcName = funcName + arg
    if (funcName==""):
        print(helpMsg)
        displayFunctions()
    else:
        displayFunction(funcName)

#load modules
os.chdir("./modules")

for file in glob.glob("*.py"):
	exec(open("./"+file).read())

os.chdir("../")

#set up console or file/str execution

def readFunc(arg):
    line = input(arg)
    if line in lineReplacements:
        line=lineReplacements[line]
    return line

readline.parse_and_bind("tab:complete")

if(len(sys.argv) > 1):
    args = sys.argv
    args = args[1:]
    if args[0]=="-f" and not (args[1] is None):
        f = open(args[1])
        if (not (f is None)):
            exec(f.read())
        #execute file
    else:
        for arg in args:
            execute = arg + " "
        execute = execute[:-1]
        exec("print("+execute+")")
else:
    #enter interactive state
    code.interact(banner=welcomeBanner, readfunc=readFunc, local=dict(globals(), **locals())) 
